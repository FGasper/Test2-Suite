<dl class="listnav">
    <dt id="tools">Tools?</dt>
    <dd>
        <h2>What are tools?</h2>

        In Test2, Tools are functions that produce testing events.
        <br /><p>
        <br /><p>

        <h3>What is a "testing event"?</h3>

        Events are generated whenever you make an assertions, set a plan, or
        produce diagnostics.
        <br /><p>
        <br /><p>

        <h3>Where can I find tools?</h3>

        Test2 makes the <b>Test2::Tools::*</b> mamespaces available to anyone
        who wants to write new tools.

        <br /><p>
        <br /><p>
        <small>Please note: not all tools are listed here.</small>
    </dd>

    <dt id="Basic">Basic</dt>
    <dd>
        <h2>Test2::Tools::Basic</h2>

        These are the 'essential' tools you always want handy.

        <br /><p>

        <script class="code">
            use Test2::Tools::Basic qw(
                ok      pass        fail            # Simple Assertions
                diag    note                        # Diagnostics
                todo    skip                        # Special Conditions
                plan    skip_all    done_testing    # Planning
                bail_out                            # Abort testing
            );

            ok(1, "passing test");
            pass("another passing test");

            todo 'fixme' => sub { fail("failing test") };

            diag "Note to STDERR";
            note "Note to STDOUT";

            done_testing;
        </script>

        See the <a href="https://metacpan.org/pod/Test2::Tools::Basic">module documentation</a> for more.
    </dd>

    <dt id="Class">Class</dt>
    <dd>
        <h2>Test2::Tools::Class</h2>

        These are tools to help you verify your classes.

        <br /><p>

        <script class="code">
            use Test2::Tools::Class qw(isa_ok can_ok DOES_ok);

            {
                package Foo::Bar::Baz;
                use parent 'Foo::Bar';

                sub foo { 'foo' }
                sub bar { 'bar' }
                sub baz { 'baz' }
            }

            my $class = 'Foo::Bar::Baz';

            isa_ok($class, 'Foo::Bar::Baz', 'Foo::Bar');
            isa_ok($class, ['Foo::Bar::Baz', 'Foo::Bar'], "test name here");

            can_ok($class, qw/foo bar baz/);
            can_ok($class, [qw/foo bar baz/], "test name here");

            DOES_ok($class, ...);
        </script>

        <small>* Note: isa_ok() takes different arguments compared to Test::More::isa_ok()</small>

        <ul>
            <li>All 3 functions are consistent.</li>
            <li>First argument is always a class or instance.</li>
            <li>All additional arguments are items to check.</li>
            <li>Each calls the object method you expect.</li>
            <li><b>NEW!</b>If the second argument is an array it is taken as a list of things to check, allowing a name as the third argument.</li>
        </ul>

        See the <a href="https://metacpan.org/pod/Test2::Tools::Class">module documentation</a> for more.
    <dd>

    <dt id="Compare">Compare</dt>
    <dd>
        <h2>Test2::Tools::Compare</h2>

        This has been moved to its own section above, see the "compare" section.
    <dd>

    <dt id="Defer">Defer</dt>
    <dd>
        <h2>Test2::Tools::Defer</h2>

        Record values now, but run test later.

        <script class="code">
            use Test2::Tools::Defer;

            BEGIN {
                def ok => (1, 'pass');
                def is => ('foo', 'foo', 'runs is');
            }

            use Test2::Tools::Basic;

            do_def(); # Run the tests

            # Declare some more tests to run later:
            def ok => (1, "another pass");
            ...

            do_def(); # run the new tests

            done_testing;
        </script>

        <ul>
            <li>def() stores the function name, and all arguments to run later.</li>
            <li>do_def() will run the stored functions and arguments.</li>
            <li>Useful if you need to test conditions before loading Test2.</li>
        </ul>
    <dd>

    <dt id="Encoding">Encoding</dt>
    <dd>
        <h2>Test2::Tools::Encoding</h2>

        <br />

        Correctly set the output encoding for the test.

        <br />

        <script class="code">
            use Test2::Tools::Encoding;

            set_encoding('utf8');
        </script>

        This seems trivial, but it is something that was very hard to do with Test::Builder.
    <dd>

    <dt id="Exception">Exception</dt>
    <dd>
        <h2>Test2::Tools::Exception</h2>

        <br />

        This is similar to Test::Fatal, but it intentionally does much less.

        <br />

        <script class="code">
            use Test2::Tools::Exception qw/dies lives/;

            like(
                dies { die 'xxx' },
                qr/xxx/,
                "Got exception"
            );

            ok(lives { ... }, "did not die") or note($@);
        </script>

        <ul>
            <li>dies { ... } will return any exception thrown, undef if no exception is thrown.</li>
            <li>lives { ... } will return false and use warn to report the exception.</li>
        </ul>

    <dd>

    <dt id="Exports">Exports</dt>
    <dd>
        <h2>Test2::Tools::Exports</h2>

        This provides tools to verifiy that methods are present in your namespace. This is intended to verify exports.

        <script class="code">
            use Test2::Tools::Exports

            use Scalar::Util qw/blessed reftype/;


            # Check that blessed() and reftype() are in our namespace.
            imported_ok(qw/blessed reftype/);


            # Check that other Scalar::Util functions were not imported.
            not_imported_ok(qw/weaken isweak refaddr/);
        </script>

        <ul>
            <li>Will not look in parent namespaces.</li>
            <li>Subs must be present in current package symbol table.</li>
            <li>People used to use can_ok() for this, but that is not correct.</li>
        </ul>
    <dd>

    <dt id="Ref">Ref</dt>
    <dd>
        <h2>Test2::Tools::Ref</h2>

        Tools for validating and comparing references.

        <br />
        <br />
        Setup:
        <script class="code">
            my $x = [1,2,3];
            my $y = [1,2,3];
            my $z = $x;
        </script>

        ref_ok() can check that something is a ref, or a ref of a specific type:
        <script class="code">
            ref_ok($y);
            ref_ok($x, 'ARRAY', '$x is an array');
        </script>

        ref_is() can check that 2 refs are the same exact ref:
        <script class="code">
            # Pass:
            ref_is($x, $z, '$x and $z are the same ref');
            ref_is($x, $y); # Fails, they are not the same ref
        </script>

        ref_is_not() is the opposite:
        <script class="code">
            # Pass:
            ref_is_not($x, $y, '$x and $y are not the same ref');
            ref_is_not($x, $z); # Fails, they are the same ref
        </script>

    <dd>

    <dt id="Subtest">Subtest</dt>
    <dd>
        <h2>Test2::Tools::Subtest</h2>

        This provides tools for writing buffered or unbuffered subtests.

        <script class="code">
            use Test2::Tools::Subtest qw/subtest_buffered/;

            subtest_buffered my_test => sub {
                ok(1, "subtest event A");
                ok(1, "subtest event B");
            };
        </script>

        <script class="output">
            ok 1 - my_test {
                ok 1 - subtest event A
                ok 2 - subtest event B
                1..2
            }
        </script>

        'Buffered' is the new Test2 style. The old Test::More style is 'streamed':

        <script class="code">
            use Test2::Tools::Subtest qw/subtest_streamed/;

            subtest_streamed my_test => sub {
                ok(1, "subtest event A");
                ok(1, "subtest event B");
            };
        </script>

        <script class="output">
            # Subtest: my_test
                ok 1 - subtest event A
                ok 2 - subtest event B
                1..2
            ok 1 - Subtest: my_test
        </script>

        <small>Note: Test2::V0 provides subtest() which is buffered.</small>
    <dd>

    <dt id="Warnings">Warnings</dt>
    <dd>
        <h2>Test2::Tools::Warnings</h2>

        This is a collection of tools that can be used to test code that issues
        warnings.

        <script class="code">
            use Test2::Tools::Warnings qw/warns warning warnings no_warnings/;

            ok(warns { warn 'a' }, "the code warns");
            ok(!warns { 1 }, "The code does not warn");
            is(warns { warn 'a'; warn 'b' }, 2, "got 2 warnings");

            ok(no_warnings { ... }, "code did not warn");

            like(warning { warn 'xxx' }, qr/xxx/, "Got expected warning");

            is(warnings { warn "a\n"; warn "b\n" }, [ "a\n", "b\n" ], "Got 2 specific warnings");
        </script>

        <ul>
            <li>warns() returns the number of warnings (and silences them)</li>
            <li>warning() returns a single warning (more than 1 is an error)</li>
            <li>warnings() return an arrayref with all warnings (always an arrayref)</li>
            <li>no_warnings() returns false if there is a warning (warnings are not silenced)</li>
        </ul>
    <dd>
</dl>

<!--
        See the <a href="https://metacpan.org/pod/Test2::Tools::">module documentation</a> for more.
-->
