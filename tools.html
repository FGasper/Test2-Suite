<dl class="listnav">
    <dt id="tools">Tools?</dt>
    <dd>
        <h2>What are tools?</h2>

        In Test2, Tools are functions that produce testing events.
        <br /><p>
        <br /><p>

        <h3>What is a "testing event"?</h3>

        Events are generated whenever you make an assertions, set a plan, or
        produce diagnostics.
        <br /><p>
        <br /><p>

        <h3>Where can I find tools?</h3>

        Test2 makes the <b>Test2::Tools::*</b> mamespaces available to anyone
        who wants to write new tools.

        <br /><p>
        <br /><p>
        <small>Please note: not all tools are listed here.</small>
    </dd>

    <dt id="Basic">Basic</dt>
    <dd>
        <h2>Test2::Tools::Basic</h2>

        These are the 'essential' tools you always want handy.

        <br /><p>

        <script class="code">
            use Test2::Tools::Basic qw(
                ok      pass        fail            # Simple Assertions
                diag    note                        # Diagnostics
                todo    skip                        # Special Conditions
                plan    skip_all    done_testing    # Planning
                bail_out                            # Abort testing
            );

            ok(1, "passing test");
            pass("another passing test");

            todo 'fixme' => sub { fail("failing test") };

            diag "Note to STDERR";
            note "Note to STDOUT";

            done_testing;
        </script>

        See the <a href="https://metacpan.org/pod/Test2::Tools::Basic">module documentation</a> for more.
    </dd>

    <dt id="Class">Class</dt>
    <dd>
        <h2>Test2::Tools::Class</h2>

        These are tools to help you verify your classes.

        <br /><p>

        <script class="code">
            use Test2::Tools::Class qw(isa_ok can_ok DOES_ok);

            {
                package Foo::Bar::Baz;
                use parent 'Foo::Bar';

                sub foo { 'foo' }
                sub bar { 'bar' }
                sub baz { 'baz' }
            }

            my $class = 'Foo::Bar::Baz';

            isa_ok($class, 'Foo::Bar::Baz', 'Foo::Bar');

            can_ok($class, qw/foo bar baz/);

            DOES_ok($class, ...);
        </script>

        <small>* Note: isa_ok() takes different arguments compared to Test::More::isa_ok()</small>

        <ul>
            <li>All 3 functions are consistent.</li>
            <li>First argument is always a class or instance.</li>
            <li>All additional arguments are items to check.</li>
            <li>Each calls the object method you expect.</li>
        </ul>

        See the <a href="https://metacpan.org/pod/Test2::Tools::Class">module documentation</a> for more.
    <dd>

    <dt id="Compare">Compare</dt>
    <dd>
        <dl class="sub_list">
            <dt id="Overview">Overview</dt>
            <dd>
                <h2>Test2::Tools::Compare</h2>

                This package provides tools for verifying deep data structures.
                It also provides the Compare DSL functions.

                <script class="code">
                    use Test2::Tools::Compare qw(
                        is like isnt unlike
                        match mismatch validator                        
                        hash array bag object meta number string subset
                        in_set not_in_set check_set
                        item field call call_list call_hash prop check
                        end filter_items
                        T F D DNE FDNE
                        exact_ref
                    );

                    # Shallow:
                    is(  "apple", "apple", "strings are equivelent");
                    like("apple", qr/ppl/, "string matches pattern");

                    # And deep:
                    is(  [1, 2, 3, 4], [1, 2, 3, 4], "arrays have the same contents");
                    like([1, 2, 3, 4], [1, 2],       "first 2 array elements match");
                </script>

                See the <a href="https://metacpan.org/pod/Test2::Tools::Compare">module documentation</a> or the sub-nav items on the bottom left for more.
            </dd>

            <dt id="State">State</dt>
            <dd>
                <h2>Simple state checks</h2>

                These are some shortcuts for checking the state of vars or nested elements.

                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ T F D DNE FDNE };

                    is(1, T(), "Check that we got a true value");
                    is(0, F(), "Check that we got a false value");
                    is(0, D(), "Check that we got a defined value");

                    is([1], [1, DNE()],  "Check that the second array element does not exist");
                    is({}, {a => DNE()}, "Check that the 'a' element does not exist");

                    is(
                        {a => 0},
                        {a => FDNE(), b => FDNE()},
                        "Check that a and b are false, or do not exist at all"
                    );
                </script>

                T() and F() may be used in nested structures, the key/element
                must exist, but may be undefined for F().
            </dd>

            <dt id="Directed">Directed</dt>
            <dd>
                <h2>Directed checks</h2>

                <p><br />

                You have some control over what type of check is used:

                <p><br />
                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ match mismatch number string exact_ref };

                    is("foo", match qr/oo/, "String matches pattern");

                    is("foo", mismatch qr/aa/, 'String does not match pattern');

                    is("12.00", number(12), "Use a numeric comparison");

                    is($thing, string($thing), "use a string comparison");

                    my $r = [];
                    is(
                        {a => $r},
                        {a => exact_ref($r)},
                        "ensure the 'a' key has the exact ref we want."
                    );
                </script>

                <p>

                <ul>
                    <li>These can all be nested as deep as you need.</li>
                    <li>They can be used in is() and like().</li>
                </ul>
            </dd>

            <dt id="Custom">Custom</dt>
            <dd>
                <h2>Custom validators</h2>

                <p><br />
                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ validator };

                    is(
                        "foo",
                        validator(sub { $_ eq 'foo' ? 1 : 0 }),
                        "Check that string is foo"
                    );

                    my $validator = validator(
                        "OP", "Check Foo",
                        sub {
                            my %params = @_;

                            my $got      = $params{got};         # Same as $_
                            my $exists   = $params{exists};      # applies to keys and elements
                            my $operator = $params{operator};    # 'OP'
                            my $name     = $params{name};        # 'Check Foo'

                            ...

                            return $bool;
                        }
                    );
                </script>
            </dd>

            <dt id="Sets">Sets</dt>
            <dd>
                <h2>Checking sets</h2>

                <p><br />
                Check that the value matches 1 OR MORE of the specified checks.
                <script class="code">
                    is('apple', in_set('pear', 'apple', 'orange'), "got a fruit");
                </script>

                <p><br />
                Check that the value DOES NOT match ANY of the specified checks.
                <script class="code">
                    is('apple', not_in_set('dog', 'cat', 'cow'), "not an animal");
                </script>

                <p><br />
                Check that the value matches ALL of the specified checks.
                <script class="code">
                    is('apple', not_in_set(match qr/pp/, match qr/a/), "matched both patterns");
                </script>
            </dd>

            <dt id="Array">Array</dt>
            <dd>
                <h2>Array Checks</h2>

                <ul>
                    <li>Array checks let you declare an array.</li>
                </ul>

                <script class="code">
                    is(
                        [qw/foo bar baz bat/],
                        array {
                            item 'foo';        # [0] First item is 'foo'
                            item match qr/a/;  # [1] second item matches /a/
                            item 3 => 'bat';   # [3] Skip right to index 3
                            end;               # Specify that there should be no more items.
                        },
                        "Array matches expectations"
                    );
                </script>

                If we change the array, we can see how nice the diagnostics are:

                <script class="code">
                    [qw/bad oops/]
                </script>

                <script class="output">
                    not ok 1 - Array matches expectations
                    # Failed test 'Array matcheds expectations'
                    # at test.pl line 9.
                    # +------+------------------+----+---------+------+
                    # | PATH | GOT              | OP | CHECK   | LNs  |
                    # +------+------------------+----+---------+------+
                    # |      | ARRAY(0x850b58)  |    | <ARRAY> | 3, 8 |
                    # | [0]  | bad              | eq | foo     | 4    |
                    # | [1]  | oops             | =~ | (?^:a)  | 5    |
                    # | [3]  | <DOES NOT EXIST> |    | bat     | 6    |
                    # +------+------------------+----+---------+------+
                    1..1
                </script>
            </dd>

            <dt id="Hash">Hash</dt>
            <dd>
                <h2>Hash Checks</h2>

                <ul>
                    <li>Hash checks let you declare a hash.</li>
                </ul>

                <script class="code">
                    is(
                        {foo => 'foo', bar => 'bar'},
                        hash {
                            field foo => 'foo';
                            field bar => match qr/a/;
                            end; # Specify that there should be no more elements.
                        },
                        "Hash matches expectations"
                    );
                </script>

                If we change the hash, we can see how nice the diagnostics are:

                <script class="code">
                    {apple => 'butter', foo => 'foops', bar => 'buurr'}
                </script>

                <script class="output">
                    not ok 1 - Hash matches expectations
                    # Failed test 'Hash matches expectations'
                    # at test.pl line 8.
                    # +---------+-----------------+---------+------------------+------+
                    # | PATH    | GOT             | OP      | CHECK            | LNs  |
                    # +---------+-----------------+---------+------------------+------+
                    # |         | HASH(0x1ff7b58) |         | <HASH>           | 3, 7 |
                    # | {foo}   | foops           | eq      | foo              | 4    |
                    # | {bar}   | buurr           | =~      | (?^:a)           | 5    |
                    # | {apple} | butter          | !exists | <DOES NOT EXIST> |      |
                    # +---------+-----------------+---------+------------------+------+
                </script>
            </dd>

            <dt id="Meta">Meta</dt>
            <dd>
                <h2>Meta Checks</h2>

                <p>
                <br />
                Meta-checks give you the ability to check the properties of a
                value.

                <p>
                <br />
                <script class="code">
                    is(
                        $thing,
                        meta {
                            prop blessed => 'My::Module'; # Ensure value is blessed as our package
                            prop reftype => 'HASH';       # Ensure value is a blessed hash
                            prop size    => 4;            # Key or element count
                            prop this    => ...;          # Check the item itself
                        },
                        "Thing matches expectations"
                    );
                </script>

                <p>
                <br />
                meta() is a sub that takes a coderef as its only argument
                (prototype).

                <p>
                <br />

                The 4 properties above are available for any type of item.
                <br />
                <small>* Except size</small>
            </dd>

            <dt id="Object">Object</dt>
            <dd>
                <h2>Object checks</h2>
                <ul>
                    <li>Object checks let you declare an object.</li>
                    <li>Can use meta-check properties.</li>
                    <li>Can use hash or array depending on the object.</li>
                </ul>

                <script class="code">
                    is(
                        bless({foo => 'foo', bar => 'bar'}, 'My::Package'),
                        object {
                            # Meta properties:
                            prop blessed => 'My::Package';

                            # Can check fields on underlying hash
                            field foo => 'foo';
                            field bar => match qr/a/;

                            # Can check results of calling methods
                            call foo => 'foo';

                            # Can check results of calling custom methods
                            call sub {[shift->list]} => ['a', 'b', 'c'];
                        },
                        "Object is as expected"
                    );
                </script>
            </dd>
        </dl>

    <dd>

    <dt id="Defer">Defer</dt>
    <dd>
        <h2>Test2::Tools::Defer</h2>

        Record values now, but run test later.

        <script class="code">
            use Test2::Tools::Defer;
        
            BEGIN {
                def ok => (1, 'pass');
                def is => ('foo', 'foo', 'runs is');
            }
        
            use Test2::Tools::Basic;
        
            do_def(); # Run the tests
        
            # Declare some more tests to run later:
            def ok => (1, "another pass");
            ...
        
            do_def(); # run the new tests
        
            done_testing;
        </script>

        <ul>
            <li>def() stores the function name, and all arguments to run later.</li>
            <li>do_def() will run the stored functions and arguments.</li>
            <li>Useful if you need to test conditions before loading Test2.</li>
        </ul>
    <dd>

    <dt id="Encoding">Encoding</dt>
    <dd>
        <h2>Test2::Tools::Encoding</h2>

        <br />

        Correctly set the output encoding for the test.

        <br />

        <script class="code">
            use Test2::Tools::Encoding;

            set_encoding('utf8');
        </script>

        This seems trivial, but it is something that was very hard to do with Test::Builder.
    <dd>

    <dt id="Exception">Exception</dt>
    <dd>
        <h2>Test2::Tools::Exception</h2>

        <br />

        This is similar to Test::Fatal, but it intentionally does much less.

        <br />

        <script class="code">
            use Test2::Tools::Exception qw/dies lives/;

            like(
                dies { die 'xxx' },
                qr/xxx/,
                "Got exception"
            );
        
            ok(lives { ... }, "did not die") or note($@);
        </script>

        <ul>
            <li>dies { ... } will return any exception thrown, undef if no exception is thrown.</li>
            <li>lives { ... } will return false and use warn to report the exception.</li>
        </ul>

    <dd>

    <dt id="Exports">Exports</dt>
    <dd>
        <h2>Test2::Tools::Exports</h2>

        This provides tools to verifiy that methods are present in your namespace. This is intended to verify exports.

        <script class="code">
            use Test2::Tools::Exports
        
            use Scalar::Util qw/blessed reftype/;


            # Check that blessed() and reftype() are in our namespace.
            imported_ok(qw/blessed reftype/);


            # Check that other Scalar::Util functions were not imported.
            not_imported_ok(qw/weaken isweak refaddr/);
        </script>

        <ul>
            <li>Will not look in parent namespaces.</li>
            <li>Subs must be present in current package symbol table.</li>
            <li>People used to use can_ok() for this, but that is not correct.</li>
        </ul>
    <dd>

    <dt id="Ref">Ref</dt>
    <dd>
        <h2>Test2::Tools::Ref</h2>

        Tools for validating and comparing references.

        <br />
        <br />
        Setup:
        <script class="code">
            my $x = [1,2,3];
            my $y = [1,2,3];
            my $z = $x;
        </script>

        ref_ok() can check that something is a ref, or a ref of a specific type:
        <script class="code">
            ref_ok($y);
            ref_ok($x, 'ARRAY', '$x is an array');
        </script>

        ref_is() can check that 2 refs are the same exact ref:
        <script class="code">
            # Pass:
            ref_is($x, $z, '$x and $z are the same ref');
            ref_is($x, $y); # Fails, they are not the same ref
        </script>

        ref_is_not() is the opposite:
        <script class="code">
            # Pass:
            ref_is($x, $y, '$x and $y are not the same ref');
            ref_is($x, $z); # Fails, they are the same ref
        </script>

    <dd>

    <dt id="Subtest">Subtest</dt>
    <dd>
        <h2>Test2::Tools::Subtest</h2>

        This provides tools for writing buffered or unbuffered subtests.

        <script class="code">
            use Test2::Tools::Subtest qw/subtest_buffered/;
    
            subtest_buffered my_test => sub {
                ok(1, "subtest event A");
                ok(1, "subtest event B");
            };
        </script>

        <script class="output">
            ok 1 - my_test {
                ok 1 - subtest event A
                ok 2 - subtest event B
                1..2
            }
        </script>

        'Buffered' is the new Test2 style. The old Test::More style is 'streamed':

        <script class="code">
            use Test2::Tools::Subtest qw/subtest_streamed/;

            subtest_streamed my_test => sub {
                ok(1, "subtest event A");
                ok(1, "subtest event B");
            };
        </script>

        <script class="output">
            # Subtest: my_test
                ok 1 - subtest event A
                ok 2 - subtest event B
                1..2
            ok 1 - Subtest: my_test
        </script>

        <small>Note: Test2::Bundle::Extended provides subtest() which is buffered.</small>
    <dd>

    <dt id="Warnings">Warnings</dt>
    <dd>
        <h2>Test2::Tools::Warnings</h2>

        This is a collection of tools that can be used to test code that issues
        warnings.

        <script class="code">
            use Test2::Tools::Warnings qw/warns warning warnings no_warnings/;

            ok(warns { warn 'a' }, "the code warns");
            ok(!warns { 1 }, "The code does not warn");
            is(warns { warn 'a'; warn 'b' }, 2, "got 2 warnings");

            ok(no_warnings { ... }, "code did not warn");

            like(warning { warn 'xxx' }, qr/xxx/, "Got expected warning");

            is(warnings { warn "a\n"; warn "b\n" }, [ "a\n", "b\n" ], "Got 2 specific warnings");
        </script>

        <ul>
            <li>warns() returns the number of warnings (and silences them)</li>
            <li>warning() returns a single warning (more than 1 is an error)</li>
            <li>warnings() return an arrayref with all warnings (always an arrayref)</li>
            <li>no_warnings() returns false if there is a warning (warnings are not silenced)</li>
        </ul>
    <dd>
</dl>

<!--
        See the <a href="https://metacpan.org/pod/Test2::Tools::">module documentation</a> for more.
-->
